# 陣列(array)
由一群**相同型態的變數**所組成的一種**資列結構**。  
陣列中個別的**元素(element)** 是以 **索引值(index)** 來標示存放的位置。    
陣列存放元素的複雜程度，分為一維，二維，三維等等陣列。  



# 一維陣列(1-Dimensional array)
## 1-Dimensional array declearation
```
資料型態 陣列名稱[個數];
```
宣告後，編譯器將分配一個**連續**區塊的記憶體。
```c
int score[3];
```
宣告整數陣列，且可以存放5個elements。

### index
```c
int score[0];
```
|score[0]|score[1]|score[2]|
|--------|--------|--------|
|第一個|第二個|第三個|
index從**0**開始，代表**第一個**元素。 
-1 為最後

```c
int main() {
    
    int i, score[4];
    
    score[0] = 0;
    score[1] = 2;
    /*score[2] = 4; 此行故意不給score[2]設值*/
    score[3] = 6;
    
    for(i=0; i<=4; i++) /*故意列印出score[4]*/
    {
        printf("score[%d] = %d\n", i, score[i]);
    }
    
    return 0;
```
由output得知，score[2]和score[4]的值為原先留在**記憶體內的殘值**。
## 陣列出值的設定
```c
int num[5] = {1, 2, 3, 4, 5};
```

若宣告時沒有將元素個數列出，編譯器會視給予得初值來決定陣列的大小
```c
int num[] = {1, 2, 3} /*3個初值，所以num的大小為3*/
```

將元素全部設為同一值
```
int num[3] = {6};
```

陣列初值得個數 > 陣列大小
```
excess element in array initializer
```

## 查詢陣列所佔的記憶體空間
```c
sizeof(array name)
```

### 範例一
```c
int main() {
    
    int num[3] = {1, 2, 3};
    int x = sizeof((num));    /*陣列所佔的位元組*/
    int y = sizeof((num[0])); /*單個元素所佔的位元組*/
    int z = x / y;            /*陣列大小*/
    printf("%d %d\n", x, y);
    printf("%d", z);
    
    return 0;
}
```

## 陣列的輸入與輸出
### 範例一 
由user輸入各element
```c
int main() {
    
    int i, num[3];
    for(i = 0; i <= 2; i++)
    {
        printf("Enter a number: ");
        scanf("%d", &num[i]);
    }
    
    for(i = 0; i < 3; i++)
    {
        printf("num[%d] = %d\n", i, num[i]);
    }
}

```
### 範例二
尋找MAX和min元素
```c
int main() {
    
    int num[5] = {1, 2, 3, 4, 99};
    int MAX = num[0], min = num[0]; /*先把最大及最小值設在第一個元素*/
    int i;
    for(i = 1; i < 5; i++) /*利用for loop去判斷每個元素*/
    {
        if(num[i] > MAX)   /*如果我比你大，我是max*/
        {
            MAX = num[i];
        }
        if(num[i] < min)
        {
            min = num[i];
        }
    }
    printf("Max = %d, min = %d", MAX, min);

    return 0;
}
```

## 陣列邊界的檢查 (不懂!!)
c語言**不會**檢查index的大小，也就是說當index超過陣列長度時，c並不會不讓使用者繼續使用該陣列，它只是將多餘的值放在陣列外的記憶體中，這樣可能會蓋掉其他的資料，或程式碼，因此產生不可預期的錯誤**(run-time error)**
```c
#define MAX 5
/*輸入五筆資料後，結束，確保不會超過arrary的大小*/
int main()
{
    int score[MAX]; /*宣告此陣列可以存放MAX個整數*/
    int i=0, num;
    float sum=0.0f;
    
    printf("請輸入成績，要結束請輸入0:\n");
    
    do
    {
        if(i == MAX) /*當i = MAX時，表示陣列已滿*/
        {
            printf("陣列空間已使用完畢!!\n");
            i++; /*i = 6, 因為下面num = i - 1*/
            break;
        }
        printf("請輸入成績: ");
        scanf("%d", &score[i]);
    }
    while(score[i++]>0); /*輸入0，結束*/
    num = i - 1;
    
    for(i=0; i<num; i++)
    {
        sum += score[i];
    }
    printf("平均成績為%.2f\n", sum/num);
}

## 尋找陣列中是否有你要的值
flag 是專門記錄搜尋的結果，flag = 1 找到符合，flag = 0 沒找到符合
    
```c
#define SIZE 6
int main()
{
    int i, num, flag = 0;
    int A[SIZE] = {33, 75, 69, 41, 33, 19};
    
    printf("array A 的元素為: ");
    for(i = 0; i<SIZE; i++)
        printf("%d ", A[i]);
        
    printf("\n請輸入愈搜尋的整數: ");
    scanf("%d", &num);
    
    for(i=0; i<SIZE; i++)
    {
        if(A[i]==num) /*判斷輸入的值是否和元素相同*/
        {
            printf("找到了");
            flag=1; /*flag = 1 代表有找到相同的值*/
        }
    }
    
    if(flag == 0)
        printf("沒有找到相同的值\n");
            
    return 0;
}
```
```
## 一微陣列的應用--**氣泡排序法(bubble sort)**
讓數值大的數字慢慢往右移，就像在水裡氣泡上浮一樣。  
從左到右，把數字**兩兩比對**，若前比後大，則前後交換。 

### 舉例: 將下列數值從小到大排序。
26 5 81 7 63
#### 第一次搜尋:    
5 26 81 7 63 (5<26，對調)
5 26 81 7 63 (26<81，不變)
5 26 7 81 63 (81>7，對調)
5 26 7 63 81 (81 > 63，對調)  
由結果得知，第一次搜尋，最大移到最右邊  

#### 第二次搜尋: 次大，到位(到應該的位置(倒數第二))
5 26 7 63 81 (5<26，不變)
5 7 26 63 81 (26>7，對調)
#### 第三次搜尋: 第三大，到位
#### 第四次搜尋: 第四大，到位
### 總結: n筆數據，搜尋n-1次

```c
void show(int a[]), bubble(int a[]); /*宣告兩個函數*/

int main()
{
    int data[5] = {1, 4, 2, 5, 3};
    bubble(data);
    show(data);
    return 0;
}

void show(int a[]) /*print array*/
{   
    int i;
    for(i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }
}

void bubble(int a[]) /*bubble sort*/
{   
    int i, j, temp; 
    for(i = 1; i < 5; i++)/*第i次搜尋, i<5 因為搜尋4次*/
    {
        for(j = 0; j < 4; j++)/*第j個元素，j<4 因為[j+1]*/
        {
            if(a[j] > a[j+1])
            {
               temp = a[j]; /*創建一個temp暫時存放a[j]*/
               a[j] = a[j + 1];
               a[j + 1] = temp;
            }
        }
    }
}
```
bubble sort雖然結果正確，但是儘管資料已完成排序，也必須不斷的重複比較，直到外層迴圈執行完畢為止，較浪費時間。  
為了改進此缺點，下面範例引進了一個旗標變數(flag)，用來控制進入外層迴圈的時機。  
出發點: 如果已經達到正確排序(無調換)，就不要進行下一波的搜尋 -> 外層for loop新增新的condition(!flag)

```c
void show(int a[]), bubble(int a[]); 

int main()
{
    int data[5] = {1, 4, 2, 5, 3};
    bubble(data);
    show(data);
    return 0;
}

void show(int a[])
{   
    int i;
    for(i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }
}

void bubble(int a[])
{   
    int i, j, temp; 
    int flag = 0; /*設定flag = 0*/
    for(i = 1; i < 5 && (!flag); i++) /*!flag = true*/
    {   
        flag = 1; /*如果沒調換，flag = 1*/
        for(j = 0; j< (5 - i); j++)
        {
            if(a[j] > a[j+1])
            {
               temp = a[j];
               a[j] = a[j + 1];
               a[j + 1] = temp;
               flag = 0; /*flag = 0*/
            }
        }
    }
}
```
搜尋過程中，若有2元素調換，則**flag = 0**; 無調換則**flag = 1**，不符合條件，不用下一回合的搜尋，陣列已完成排序。
